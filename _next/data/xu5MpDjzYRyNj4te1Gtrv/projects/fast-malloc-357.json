{"pageProps":{"project":{"id":18,"slug":"fast-malloc-357","assetRoot":"projects/fast-malloc-357","title":"Fast malloc() Implementation","status":"complete","description":"2nd fastest in the class!","startDate":"2020-07-01T00:00:00.000Z","endDate":"2020-07-30T00:00:00.000Z","url":null,"source":["mailto:hi@astrid.tech"],"thumbnail":null,"content":"<p>This is an implementation of the <code>malloc()</code> command in C that was second-fastest in a class of 30 students for a certain performance benchmark. My runtime was 169us, whereas the fastest one’s runtime was 160us. If you would like to see the code, please email me at <a href=\"mailto:hi@astrid.tech\">hi@astrid.tech</a>.</p>\n<h2 id=\"introduction\">Introduction</h2>\n<p>In almost every language, a lot of the memory management is done under the hood for you. With garbage-collected langs, like Python and Java, you literally just create an object and bam, memory. Even with C and C++, you can call <code>malloc()</code> and <code>free()</code>. No finagling with the program break and memory chunks.</p>\n<p>So what if you’re not allowed to use <code>malloc()</code> and <code>free()</code>? In my CPE 357 (systems programming) class, we were given an assignment to write our own <code>malloc()</code> and <code>free()</code> functions, moving the program break forward and backward manually with <code>brk()</code> and <code>sbrk()</code>. There is extra credit if your program is one of the top 5 fastest in the class for the following benchmark:</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">90</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">95</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\na<span class=\"token punctuation\">[</span><span class=\"token number\">95</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">90</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>Naturally, like the overachieving idiot I am, I decided to go for it.</p>\n<h2 id=\"analysis-of-the-benchmark\">Analysis of the benchmark</h2>\n<p>The example implementation was to have a doubly-linked list of nodes, relying heavily on linear searches. Performing a <code>malloc()</code> will do a linear search through the chunks for the next free one. You can imagine how that implementation might not hold up so well.</p>\n<p>We can break up the benchmark into the component parts to figure out how best to game the system.</p>\n<h3 id=\"long-sequential-allocation\">Long sequential allocation</h3>\n<p>The heap starts out empty, like this:</p>\n<img src=\"/_/projects/fast-malloc-357/a4b8a213a673823734ae11d2221f8b5fe55d9817.svg\" title=\"&#x60;dot&#x60; image\">\n<p>This first section will allocate sequential memory chunks:</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<img src=\"/_/projects/fast-malloc-357/48d8f682eecb213c29a73f5fa4754c4be945869b.svg\" title=\"&#x60;dot&#x60; image\">\n<p>Already, we can see that this code will cause the example implementation will go through all the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> existing chunks every single loop, like so:</p>\n<img src=\"/_/projects/fast-malloc-357/3125ea813f79d4823cf3c1eb186b8aad100821ea.svg\" title=\"&#x60;dot&#x60; image\">\n<p>Since we’re scanning <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> items <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span> times, this is already <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>! This can definitely be improved, as we’ll see later.</p>\n<h3 id=\"long-sequential-freeing\">Long sequential freeing</h3>\n<p>This second section will sequentially free most of the chunks.</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">90</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<img src=\"/_/projects/fast-malloc-357/b6cd21dc784ffe3cf05ec7f65ef7ba8cc81d22b8.svg\" title=\"&#x60;dot&#x60; image\">\n<h3 id=\"freeing-in-the-middle\">Freeing in the middle</h3>\n<p>This third section frees a chunk in the middle of some sequentially-allocated chunks.</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span><span class=\"token number\">95</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<img src=\"/_/projects/fast-malloc-357/95936f95715007c666124883fb7ef42099ecb717.svg\" title=\"&#x60;dot&#x60; image\">\n<p>Note that since we’re scanning from the start, we had to look through 6 nodes (0, 90, 91, 92, 93, 94) before reaching the one we wanted (95), making this <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>. While not terrible, this could be improved as well.</p>\n<h3 id=\"allocating-into-the-best-fit\">Allocating into the best fit</h3>\n<p>The next malloc is expected to take that chunk that has just been freed because it’s the smallest one that it can fit in.</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\">a<span class=\"token punctuation\">[</span><span class=\"token number\">95</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">malloc</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<img src=\"/_/projects/fast-malloc-357/a9465362f1fc1c3875dbe56efa388352fc7e2b86.svg\" title=\"&#x60;dot&#x60; image\">\n<p>The <code>malloc()</code> here did the same thing as the free above. Once again, not terrible, but not optimal either.</p>\n<h3 id=\"free-everything\">Free everything</h3>\n<p>This final section frees the rest of the chunks. The expected result is that the heap becomes empty.</p>\n<div class=\"remark-highlight\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">90</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&#x3C;</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span>\n    <span class=\"token function\">free</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<img src=\"/_/projects/fast-malloc-357/a4b8a213a673823734ae11d2221f8b5fe55d9817.svg\" title=\"&#x60;dot&#x60; image\">\n<p>Every single <code>free()</code> is 1 link away from the heap start, so in this case, it will be <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span>.</p>\n<h2 id=\"how-could-we-improve-this\">How could we improve this?</h2>\n<p>The greatest amount of time comes from the first part, the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> sequential <code>malloc()</code>. In a test I ran, using this implementation took about 200us on my computer, while my more optimized implementation was only 160us! The solution I came up with also ended up making every single one of the <code>malloc()</code>s and <code>free()</code>s on this benchmark <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> (though, once again, only for this benchmark).</p>\n<p>It was fairly simple: besides keeping a doubly-linked list for node order, also keep a doubly-linked list for free nodes. In this benchmark, there are never more than 2 free nodes, so scanning through the free node list is extremely cheap. It does require a bit of extra bookkeeping every time you free or allocate a chunk, however, but it the benefits massively outweighed the downsides.</p>\n<h2 id=\"going-further\">Going further</h2>\n<p>I attempted to try and go even further by replacing the doubly-linked list with an <a href=\"https://en.wikipedia.org/wiki/Unrolled_linked_list\">unrolled linked list</a>, which is like if an array list and a linked list had a child. Its main benefit is that it has the best of both worlds: you can stick on an infinite number of elements onto the end without having to reallocate the whole thing every now and then unlike an array list, but it’s also much more cache efficient than a linked list.</p>\n<p>I was going somewhat overkill on it, too: 64 bytes wide and aligned to 64-byte boundaries so that the entire thing fits on a single cache line, and using 128 bit registers to copy them for even more efficiency, among other things. I would have even attempted to use AVX/AVX2 registers to permute them in a single instruction, if not for:</p>\n<p>a. the fact that my professor told me that that was forbidden, and\nb. the fact that I ran out of time attempting to implement this godforsaken thing</p>\n<p>So in the end, I just submitted my doubly-linked free list implementation.</p>\n<p>If the benchmark weren’t as sequential, and had more random accesses causing more fragmentation, I probably would have used a free chunk BST keyed by node size, so that I can have <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> rather than <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> free node scanning. This is because the best fit is the smallest chunk that fully contains the size you’re allocating, so we would want to be able to do a search for that node on an ordered collection.</p>","tags":["c","school:cal-poly=cpe-357"]},"similar":[]},"__N_SSG":true}